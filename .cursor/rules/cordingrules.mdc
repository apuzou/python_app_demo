---
alwaysApply: true
---

# cursorrules（Python / FastAPI 汎用）

## 最重要原則（他のすべてのルールより優先される）

迷ったらこの順で判断する。下に行くほど優先度が下がる。

1. **可読性が最優先（clarity > cleverness）**  
   読めば意図が伝わるコードを選ぶ。賢いワンライナーや過剰な抽象化は避ける。
2. **Explicit is better than implicit**  
   前提・制約・例外・型・設定はコード上に明示する（暗黙の仕様を作らない）。
3. **振る舞いは予測可能であること**  
   例外・戻り値・副作用・I/O境界を明確にし、同じ入力に対して同じ結果になりやすい設計を選ぶ。
4. **変更容易性（changeability）を最優先にする**  
   将来の変更コストが低い構造を選ぶ。責務分離・依存方向・テスト容易性を重視する。
5. **YAGNI / 不必要な複雑さを増やさない**  
   “将来必要そう”だけで仕組みを増やさない。今必要な最小構成で作り、必要になってから拡張する。

---

## 0. 目的

- 変更に強く、読みやすく、テストしやすく、安全で、運用に耐えるコードを書く。
- 追加実装は「最小差分・明確な責務・予測可能な挙動」を最優先にする。
- 過度な抽象化よりも、理解しやすさと一貫性を優先する。

---

## 1. 実装前の必須プロセス（いきなり書き始めない）

- まず **要件を3点に要約**する（目的 / 入出力 / 制約）。
- 影響範囲を明確にする：
  - 変更対象ファイル
  - 新規追加ファイル
  - 既存APIとの互換性
  - データ形式の変更有無
- エッジケースを先に列挙する（None / 空 / 異常値 / timeout / 外部依存の失敗）。
- 実装方針を **箇条書き5行以内**で提示してからコードを書く。
- 不明点がある場合は仮定を明示する（暗黙の前提で実装しない）。

---

## 2. 設計原則（迷ったらここに戻る）

- **Single Responsibility Principle** を守る。  
  1関数 / 1クラスは「1つの理由」でしか変更されない状態にする。
- **ビジネスロジックとI/Oを分離**する。  
  ロジックは可能な限り pure function に寄せ、DB / HTTP / ファイル操作は境界層に隔離する。
- **Dependency Injection** を基本とする。  
  依存は引数やコンストラクタで渡し、グローバル状態に依存しない。
- 暗黙の仕様を作らない。  
  型、validation、例外で前提を明示する。
- 例外は「境界」で変換する（内側の意味を保ったまま外側へ伝える）。

---

## 3. 変更方針（最小差分ルール）

- 既存コードの設計・命名・構造を尊重する。
- 無関係な整形・import並び替え・大規模リファクタは禁止。
- 振る舞いが変わる場合は明示する（何がどう変わるかを具体的に）。
- 破壊的変更を行う場合は、代替案または移行手順を示す。

---

## 4. Python コーディング規約

### 4.1 type hints と docstring

- 公開関数・主要ロジックには **type hints を必須**とする。
- `Any` の使用は最小限にし、理由をコメントで明示する。
- docstring には以下を簡潔に記載する：
  - 何をするか（what）
  - なぜ必要か（why）
  - 発生しうる例外（raises）
- 実装方法（how）はコードで表現する。

### 4.2 命名

- 変数は意味がわかる名詞。
- 関数は動詞で始める（`get_`, `build_`, `validate_`, `parse_`）。
- 一般的な略語（id, url, db）は可。不明瞭な略語は禁止。

### 4.3 エラー処理

- `except Exception: pass` は禁止。
- 想定する失敗は「握る」のではなく「扱う」：
  - リカバリできるなら分岐・retry・fallback
  - リカバリできないなら意味のある例外を投げる
- 失敗時のメッセージは「何が起きたか」と「調査に必要な情報（キー/条件）」を含める。
- 境界層（FastAPI層など）で、ユーザー向けエラーと内部エラーを分離する。

### 4.4 可読性

- ネストは浅く保つ。
- 積極的に **early return** を使う（ガード節で先に弾く）。
- 1関数は長くしすぎない（画面1枚で読める範囲）。超えたら分割する。
- “賢いワンライナー”よりも明確な複数行を選ぶ。

### 4.5 データ構造

- 意味のあるデータは `dataclass` や Pydantic model、TypedDict で表現する。
- マジックナンバー・マジック文字列は禁止。定数または Enum を使用する。

---

## 5. FastAPI 実装ルール

- ルータ層は薄く保つ（Controllerは薄く、Serviceに寄せる）：
  - 入力受け取り
  - validation
  - レスポンス整形
  - 例外変換
- ビジネスロジックは service 層へ分離する。
- すべてのエンドポイントで成功ケースと失敗ケースを明示的に扱う。
- timeout や retry はルータ内に直接書かない（呼び出し境界・クライアント層に置く）。
- エラーレスポンス形式は統一する（例：`{"detail": "...", "code": "..."}`）。

---

## 6. async / concurrency ルール

- `async def` 内でブロッキングI/Oを行わない。
- 重い処理は別レイヤーに逃がす設計にする（同期I/Oは thread / worker 等を検討）。
- `asyncio.gather` は例外伝播と cancel の挙動を理解した上で使用する。
- 不要な並列化は禁止（可読性と予測可能性を優先）。

---

## 7. ログ設計

- 可能なら structured logging を想定し、ログは調査可能な形で出す。
- 出力すべき情報：
  - request_id 相当
  - 対象ID
  - 処理名
  - 所要時間
- 秘密情報（token, password, API key等）は絶対に出力しない。
- ユーザー向けエラーと内部ログを分離する。

---

## 8. テスト方針

- 変更したロジックには必ずテストを追加する。
- 最低限テストすべきもの：
  - 正常系
  - 異常系（validation / 例外）
  - 境界値（空 / 0 / 最大 / None）
- Arrange / Act / Assert を明確にする。
- 外部I/Oは境界で mock / stub し、ロジックは純粋に検証する。
- テストが読めば仕様がわかる状態にする。

---

## 9. セキュリティ最低ライン

- 入力は信用しない（validation + 許可リスト）。
- 例外メッセージで内部情報（SQL, path, secret）を漏らさない。
- ファイルパスやURLは必ず検証し、制約を明示する。

---

## 10. 仕上げチェックリスト

- 未使用importがない。
- debug用printが残っていない。
- type hints と戻り値が一致している。
- 例外設計が一貫している。
- テストが通る。
- 変更点を説明できる。

---

## 11. 出力フォーマット（Cursor用）

変更提案は以下の順で提示する：

1. 変更概要
2. 変更ファイル一覧
3. コード（必要ならdiff形式）
4. 追加・更新テスト
5. 動作確認手順

コードは「動く最小」を優先する。

TODOを書く場合は理由を明示する：

```python
# TODO: パフォーマンス改善（負荷増加時に対応）
```

## 12. 禁止事項
-	根拠のない大規模リファクタ
-	無関係な整形
-	例外の握りつぶし
-	グローバル可変状態の安易な導入
-	推測ベースの仕様確定(推測する場合は必ず仮定を明記し、後から差し替え可能にする。)
